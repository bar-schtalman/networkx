import networkx as nx
from math import comb
import random


basic_RG = nx.DiGraph()
basic_RG.add_nodes_from(range(6, 10))
edges = [(6, 7), (6, 8), (6, 9), (8, 8), (9, 7), (9, 8), (9, 9)]
basic_RG.add_edges_from(edges)

stupid_RG = nx.DiGraph()
stupid_RG.add_nodes_from(range(1, 7))
edges = [(1, 4), (2, 5), (3, 6)]
stupid_RG.add_edges_from(edges)

fork_DG = nx.DiGraph()
fork_DG.add_nodes_from(range(1, 4))
edges = [(1, 2), (2, 3)]
fork_DG.add_edges_from(edges)

data = {'basic_code': basic_RG, 'stupid_code': stupid_RG, 'fork_code': fork_DG}

fork_v1_DG = nx.DiGraph()
fork_v1_DG.add_nodes_from(range(1, 15))
edges = [(1, 4), (2, 6), (3, 5), (4, 7), (5, 8), (5, 10), (10, 10)]
fork_v1_DG.add_edges_from(edges)

stupid_DG_v1 = nx.DiGraph()
stupid_DG_v1.add_nodes_from(range(1, 7))
edges = [(1, 4), (2, 5), (3, 6)]
stupid_DG_v1.add_edges_from(edges)

basic_DG_v1 = nx.DiGraph()
basic_DG_v1.add_nodes_from(range(1, 12))
edges = [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8), (6, 7),
         (6, 8), (6, 9), (8, 8), (9, 7), (9, 8), (9, 9)]
basic_DG_v1.add_edges_from(edges)


basic_DG_v2 = nx.DiGraph()
basic_DG_v2.add_nodes_from(range(1, 12))
edges = [(1, 3), (2, 6), (4, 5), (3, 8), (6, 7), (6, 8),
         (6, 9), (5, 7), (9, 7), (9, 8), (9, 9), (8, 8)]
basic_DG_v2.add_edges_from(edges)

basic_DG_v3 = nx.DiGraph()
basic_DG_v3.add_nodes_from(range(1, 12))
edges = [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8), (6, 7),
         (6, 8), (6, 9), (8, 8), (9, 7), (9, 8), (9, 9)]
basic_DG_v3.add_edges_from(edges)

basic_DG_v4 = nx.DiGraph()
basic_DG_v4.add_nodes_from(range(1, 12))
edges = [(1, 5), (2, 6), (3, 4), (4, 5), (5, 8), (6, 7),
         (6, 8), (6, 9), (8, 8), (9, 7), (9, 8), (9, 9)]
basic_DG_v4.add_edges_from(edges)

basic_DG_v5 = nx.DiGraph()
basic_DG_v5.add_nodes_from(range(1, 14))
edges = [(1, 11), (2, 12), (3, 10), (11, 6), (12, 6), (12, 7),
         (12, 5), (10, 5), (6, 6), (7, 6), (7, 7), (7, 5)]
basic_DG_v5.add_edges_from(edges)


def count_equal_size_combinations(G1_nodes, G2_nodes):
    # Find the smaller of the two graphs
    smaller_g = G1_nodes if len(G1_nodes) < len(G2_nodes) else G2_nodes

    # Initialize the count to 0
    count = 0

    # Iterate over all subgraph sizes from 0 to the size of the smaller graph
    for i in range(1, len(smaller_g) + 1):
        # Calculate the number of combinations for g1
        g1_combinations = comb(len(G1_nodes), i)

        # Calculate the number of combinations for g2
        g2_combinations = comb(len(G2_nodes), i)

        # Add the total number of combinations for this size to the count
        count += g1_combinations * g2_combinations

    return count


def fitness(sub_G1, sub_G2, G1_nodes, G1_edges, G2_nodes, G2_edges):
    """
    fitness function to calculate the quality of the solution
    given two sub graphs, and the original graphs size
    """
    if nx.is_isomorphic(sub_G1, sub_G2):
        min_val = 0
        if G1_nodes < G2_nodes:
            min_val = G1_edges
        else:
            min_val = G2_edges
        mutual = len(sub_G2.edges)
        return (((G1_edges - mutual) + (G2_edges - mutual)) / min_val)
    else:
        return 999999


def GA(G1, G2, ALPHA=0):
    G1_nodes = list(G1.nodes)
    G2_nodes = list(G2.nodes)
    G1_nodes_len = len(G1_nodes)
    G1_edges_len = len(G1.edges)
    G2_nodes_len = len(G2_nodes)
    G2_edges_len = len(G2.edges)
    # calculates the num of combinations
    num_of_combinations = count_equal_size_combinations(G1_nodes, G2_nodes)
    # generate solutions
    solutions = []
    min_nodes = min(len(G1_nodes), len(G2_nodes))
    NUM_OF_SOLUTIONS = int(num_of_combinations / 4)
    for s in range(NUM_OF_SOLUTIONS):
        sub_graph_size = random.randint(1, min_nodes)
        sub1 = random.sample(G1_nodes, sub_graph_size)
        sub2 = random.sample(G2_nodes, sub_graph_size)
        solutions.append((sub1, sub2))
    # print("solutions:", solutions)
    NUM_OF_GENERATIONS = int(NUM_OF_SOLUTIONS*2)
    for i in range(NUM_OF_GENERATIONS):
        rankedsolutions = []  # [solution, fitness' score]
        for s in solutions:
            fitness_score = fitness(G1.subgraph(s[0]), G2.subgraph(
                s[1]), G1_nodes_len, G1_edges_len, G2_nodes_len, G2_edges_len)
            rankedsolutions.append((s, fitness_score))
        # print(f"=== Gen {i+1} best solutions === ")
        # print(rankedsolutions[0])
        # checks if the best solution so fate is less or equals to alpha
        if rankedsolutions[0][1] <= ALPHA:
            # print('--------------------------------------------------------VIRUS-DETECTED--------------------------------------------------------')
            return True
            # sorts the solutaions by thier fitness' score
        rankedsolutions = sorted(rankedsolutions, key=lambda x: x[1])
        SOLUTIONS_TO_CHOOSE = int(NUM_OF_SOLUTIONS * 0.8)
        # picks the smallest SOLUTIONS_TO_CHOOSE solutions
        bestsoutions = rankedsolutions[:SOLUTIONS_TO_CHOOSE]
        G1_elements = []
        G2_elements = []
        for s in bestsoutions:
            # print("s:", s)
            G1_sub = s[0][0]  # takes the solution for G1
            G2_sub = s[0][1]  # takes the solution for G2
            G1_elements.append(G1_sub)
            G2_elements.append(G2_sub)
        # print("G1_elements:", G1_elements)
        # print("G2_elements:", G2_elements)

        G1_lengths = set([len(lst) for lst in G1_elements])
        # print("G1_lengths:", G1_lengths)
        G2_lengths = set([len(lst) for lst in G2_elements])
        # print("G2_lengths:", G2_lengths)
        intersection = list(G1_lengths.intersection(G2_lengths))

        G1_sublists = {}
        G2_sublists = {}

        for length in intersection:
            G1_sublists[length] = [
                lst for lst in G1_elements if len(lst) == length]
            G2_sublists[length] = [
                lst for lst in G2_elements if len(lst) == length]

        newGen = []
        #[([1,2], [2,3]), fitness]
        count_new_solutions = 0
        while (count_new_solutions < NUM_OF_SOLUTIONS):
            sub_graph_size = random.choice(intersection)
            e1 = random.choice(G1_sublists[sub_graph_size])
            e2 = random.choice(G2_sublists[sub_graph_size])
            # print("(e1, e2):", (e1, e2))
            if (e1, e2) not in newGen:
                newGen.append((e1, e2))
            else:
                new_e1 = random.sample(G1_nodes, sub_graph_size)
                new_e2 = random.sample(G2_nodes, sub_graph_size)
                newGen.append((new_e1, new_e2))
            count_new_solutions += 1

        solutions = newGen
        # print("newGen: ", newGen)
    return False


def build_RG_from_DG(G):
  nodes_to_remove = []  # contains all the nodes that should be removed
  isolated_nodes = []  # contains all the nodes that does not has any edge
  for v in G.nodes:
    edges_in = G.in_degree(v)
    edges_out = G.out_degree(v)
    if edges_in <= 1 and edges_out <= 1:  # checks for each node if it should be removed
        if edges_in == 0 and edges_out == 0:
          isolated_nodes.append(v)
        else:
          nodes_to_remove.append(v)
  # removes all the islolated nodes from G
  G.remove_nodes_from(isolated_nodes)
  # in case that all the nodes should be removed, we will return the original graph without the isolated nodes
  if len(nodes_to_remove) == len(G.nodes):
    return G
  # otherwise, we will remove those nodes as well
  else:
    g_tag = G
    g_tag.remove_nodes_from(nodes_to_remove)
    return g_tag


def malware_detection(G1, alpha):
    RG1 = build_RG_from_DG(G1)
    ans = False
    for i in data:
        G2 = data[i]
        ans = GA(RG1, G2, alpha)
        if ans == True:
            return "Malware"
    if ans == False:
        return "Benign"


print(malware_detection(basic_DG_v3, 0))
